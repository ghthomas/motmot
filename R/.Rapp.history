y
from.here
start <- which(ext == y)#
	from.here <- start.root[max(which(start > start.root))]
from.here
from.here:start
start.root
library(motmot.2.0)#
#
phy <- rcoal(10)#
phy <- reorder(phy)#
plot(phy)#
edgelabels(signif(phy$edge.length, 3))#
#
all.nodes <- (Ntip(phy) + 2) : (Ntip(phy) + Nnode(phy))#
#
node.des <- sapply(all.nodes , function(x) {#
	x.x <- node.descendents(x, phy, tip.labels=T)#
	length(x.x[[2]])#
})#
ed.one <- phy$edge.length / c(rep(1, Ntip(phy)), node.des)[tapply(c(1:Ntip(phy), all.nodes ), phy$edge[,2])]#
#
ext <- phy$edge[,2]#
int <- phy$edge[,1]#
root <- Ntip(phy) + 1
ed.one
nodeTims
nodeTimes
node.depth.edgelength
node.depth
which(root == int)
start <- which(root == int)
ext.st <- ext[start]
ext.st
start <- which(root == int)[1]
ext.st <- ext[start]
ext.st
start <- which(root == int)[2]
ext.st <- ext[start]
ext.st
which(ext.st == int)
start <- which(ext.st == int)
ext[start]
ext.st <- ext[start]
start <- which(ext.st == int)
start
ext.st
int
start <- sapply(ext.st, function(x) which(x == int))
start
start <- which(root == int)[2]#
ext.st <- ext[start]#
#
start <- unlist(sapply(ext.st, function(x) which(x == int)))#
ext.st <- ext[start]
ext.st
start <- unlist(sapply(ext.st, function(x) which(x == int)))
start
s
ext.st <- ext[start]
start <- which(root == int)[2]#
ext.st <- ext[start]#
#
start <- unlist(sapply(ext.st, function(x) which(x == int)))#
ext.st <- ext[start]
start <- unlist(sapply(ext.st, function(x) which(x == int)))
ext.st <- ext[start]
start <- unlist(sapply(ext.st, function(x) which(x == int)))
start
sapply(ext.st, function(x) which(x == int))
start <- which(root == int)[2]
phy$edge
which(root == int)[2]
start
ext[start]
ext.st <- ext[start]
start <- unlist(sapply(ext.st, function(x) which(x == int)))
start
sapply(ext.st, function(x) which(x == int))
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
start
ext[start]
ext.st <- ext[start]
c(unlist(sapply(ext.st, function(x) which(x == int))))
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
ext.st <- ext[start]
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
start
ext.st <- ext[start]
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
start
ext.st <- ext[start]
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
start
ext.st <- ext[start]
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
start
ext.st <- ext[start]
start <- which(root == int)[1]
start
ext.st <- ext[start]
ext.st
ed.one[start]
rep(0, Ntip(phy) - 2)
rep(0, Ntip(phy) * 2 - 2)
Ntip(phy) * 2 - 2
ed.count <- rep(0, Ntip(phy) * 2 - 2)
ed.count <- ed.one[start]
ed.count
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
start
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
#
ed.count <- ed.one[start]
ed.count
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
start
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
#
ed.count <- ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
start
ed.count <- temp <-  ed.one[start]
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
#
ed.count <- temp <-  ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- ed.count[start] + temp#
ext.st <- ext[start]
ext.st
ed.count <- temp <-  ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- ed.count[start] + temp#
ext.st <- ext[start]
ed.count
ed.count <- rep(0, Ntip(phy) * 2 - 2)
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
#
ed.count[start] <- temp <-  ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- ed.count[start] + temp#
ext.st <- ext[start]
ed.count[start]
ed.count <- rep(0, Ntip(phy) * 2 - 2)
ed.count
ed.count[start] <- temp <-  ed.one[start]
ed.count
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]
ed.count
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]
ed.count
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]
ed.count
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- ed.count[start] + temp#
ext.st <- ext[start]
ed.count
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- ed.count[start] + temp#
ext.st <- ext[start]#
ed.count
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
#
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- ed.count[start] + temp#
ext.st <- ext[start]#
ed.count
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- ed.count[start] + temp#
ext.st <- ext[start]#
ed.count
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
#
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- temp <- ed.count[start] + temp#
ext.st <- ext[start]#
ed.count
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- temp <- ed.count[start] + temp#
ext.st <- ext[start]#
ed.count
ext <- phy$edge[,2]#
int <- phy$edge[,1]#
root <- Ntip(phy) + 1#
#
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
#
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]
ed.count
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
start
ed.count[start] + temp
ed.count[start] <- temp <- ed.count[start] + temp
ed.count
ed.count[start]
ext <- phy$edge[,2]#
int <- phy$edge[,1]#
root <- Ntip(phy) + 1#
#
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
#
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- temp <- ed.count[start] + temp#
ext.st <- ext[start]#
ed.count
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
start
ed.count[start]
ext <- phy$edge[,2]#
int <- phy$edge[,1]#
root <- Ntip(phy) + 1#
#
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
#
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- temp <- ed.one[start] + temp#
ext.st <- ext[start]#
ed.count
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- temp <- ed.one[start] + temp#
ext.st <- ext[start]#
ed.count
temp
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
#
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- temp <- ed.one[start][1] + temp[1]#
ext.st <- ext[start]#
ed.count
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- temp <- ed.one[start][1] + temp[1]#
ext.st <- ext[start]#
ed.count
fairProportions(phy)[,1]
which(ext <= Ntip(phy))
ed.count[which(ext <= Ntip(phy))]
fairProportions(phy)[,1]
ed.count[which(ext > Ntip(phy))]
ed.count[which(ext >= Ntip(phy))]
ed.count
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]
temp
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]
temp
ed.count
fairProportions(phy)[,1]
which(ext >= Ntip(phy))
which(ext < Ntip(phy))
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
start
ed.one[start]
temp
ed.one[start] + temp
ed.one[start]
ed.one[start] + temp
ed.count[start]
start
ext <- phy$edge[,2]#
int <- phy$edge[,1]#
root <- Ntip(phy) + 1#
#
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
#
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- temp <- ed.one[start] + temp#
ext.st <- ext[start]#
ed.count
ed.count[which(ext < Ntip(phy))]
fairProportions(phy)[,1]
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- temp <- ed.one[start] + temp#
ext.st <- ext[start]#
ed.count
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
#
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- temp <- ed.one[start] + temp#
ext.st <- ext[start]#
ed.count#
#
ed.count[which(ext < Ntip(phy))]
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- temp <- ed.one[start] + temp#
ext.st <- ext[start]#
ed.count#
#
ed.count[which(ext < Ntip(phy))]
fairProportions(phy)[,1]
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
#
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))#
ed.count[start] <- temp <- ed.one[start] + temp#
ext.st <- ext[start]#
ed.count
ed.count[which(ext < Ntip(phy))]
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
start
ed.one[start] + temp
start
ed.count
which(ext < Ntip(phy))
ed.count[start] <- temp <- ed.one[start] + temp
ext.st <- ext[start]
ed.count
ed.count[which(ext < Ntip(phy))]
start <- c(unlist(sapply(ext.st, function(x) which(x == int))))
ed.one[start] + temp
ext <- phy$edge[,2]#
int <- phy$edge[,1]#
root <- Ntip(phy) + 1#
#
ed.count <- rep(0, Ntip(phy) * 2 - 2)#
start <- which(root == int)[1]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]#
#
start <- which(root == int)[2]#
ext.st <- ext[start]#
ed.count[start] <- temp <-  ed.one[start]
ed.count
library(motmot.2.0, quietly=T)#
data(anolis.tree)#
data(anolis.data)#
#
names(anolis.data)#
attach(anolis.data)#
anolis.tree#
#
male.length <- matrix(Male_SVL, dimnames=list(rownames(anolis.data)))#
any(is.na(male.length[,1]))#
#
complete.male.length <- complete.cases(male.length)#
missing.species <- rownames(male.length)[!complete.male.length]#
male.length <- as.matrix(male.length[complete.male.length, ])#
male.length <- log(male.length)#
#
phy <- drop.tip(anolis.tree, missing.species)#
name.check(phy, male.length)#
#
traitData.plot(y=male.length, phy)#
#
bm.ml <- transformPhylo.ML(phy, y=male.length, model="bm")#
bm.ml#
lambda.ml <- transformPhylo.ML(phy, y=male.length, model="lambda")#
lambda.ml
acdc.ml <- transformPhylo.ML(phy, y=male.length, model="ACDC", profilePlot=T)
y=male.length
acdcRate <- -0.01
node <- Ntip(phy) + 1
rootBranchingTime <- nodeTimes(phy)[1, 1]
bounds <- matrix(c(1e-08, 1, 1e-08, 1, 1e-08, 5, 1e-08, 20, 0, 1, 1e-08, 1000, 1e-10, 20), 7, 2, byrow = TRUE)#
    rownames(bounds) <-#
      c("kappa", "lambda", "delta", "alpha", "psi", "rate", "acdcRate")#
    aic.fun <- function(likelihood, k) return(-2 * likelihood + 2 * k)#
    aicc.fun <- function(likelihood, k, n) return(-2 * likelihood + 2 * k + ((2 * k * (k + 1)) / (n - k - 1)))
rootBranchingTime <- nodeTimes(phy)[1, 1]
log(bounds["acdcRate", 1]) / rootBranchingTime
lowerBound <- log(bounds["acdcRate", 1]) / rootBranchingTime
lowerBound <- c(lowerBound, bounds["lambda", 1])
lowerBound <- log(bounds["acdcRate", 1]) / rootBranchingTime
upperBound <- log(bounds["acdcRate", 2]) / rootBranchingTime
var.funACDC <- function(param) {#
            if (lambdaEst) lambda <- param[2] else lambda <- 1#
            acdc.est <- param[1]#
            lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
            return(transformPhylo.ll(lambdaPhy, acdcRate = acdc.est, nodeIDs = node, model = "ACDC", y = y, cladeRates = 1, meserr = meserr, covPIC = covPIC)[[2]])
}
vo <- optim(acdcRate, var.funACDC, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)
vo <- optim(acdcRate, var.funACDC, method = "L-BFGS-B", lower = lowerBound, upper = upperBound)
y=male.length.clade#
 modelCIs = TRUE#
 nodeIDs = NULL#
 lambdaEst = FALSE#
 acdcScalar = FALSE#
 profilePlot = T#
 lowerBound = NULL#
 upperBound = NULL#
 covPIC = TRUE#
 n.cores = 1#
 tol = NULL#
 meserr=NULL#
 controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5)#
 returnPhy = FALSE
acdcRate <- -0.01#
        if (acdcScalar)#
          acdcRate[2] <- 1#
        if (lambdaEst)#
          acdcRate <- c(acdcRate, 1)#
        if (is.null(nodeIDs))#
          node <- Ntip(phy) + 1#
        else#
          node <- nodeIDs#
        rootBranchingTime <- nodeTimes(phy)[1, 1]#
        if (is.null(lowerBound)) {#
          lowerBound <- log(bounds["acdcRate", 1]) / rootBranchingTime#
          if (acdcScalar)#
            lowerBound[2] <- 1#
          if (lambdaEst)#
            lowerBound <- c(lowerBound, bounds["lambda", 1])#
        }#
        if (is.null(upperBound)) {#
          upperBound <- log(bounds["acdcRate", 2]) / rootBranchingTime#
          if (acdcScalar)#
            upperBound[2] <- 20#
          if (lambdaEst)#
            upperBound <- c(upperBound, bounds["lambda", 2])#
        }
y=male.length.clade#
 modelCIs = TRUE#
 nodeIDs = NULL#
 lambdaEst = FALSE#
 acdcScalar = FALSE#
 profilePlot = T#
 lowerBound = NULL#
 upperBound = NULL#
 covPIC = TRUE#
 n.cores = 1#
 tol = NULL#
 meserr=NULL#
 controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5)#
 returnPhy = FALSE
acdcRate <- -0.01#
        if (acdcScalar)#
          acdcRate[2] <- 1#
        if (lambdaEst)#
          acdcRate <- c(acdcRate, 1)#
        if (is.null(nodeIDs))#
          node <- Ntip(phy) + 1 else node <- nodeIDs#
        rootBranchingTime <- nodeTimes(phy)[1, 1]#
        if (is.null(lowerBound)) {#
          lowerBound <- log(bounds["acdcRate", 1]) / rootBranchingTime#
          if (acdcScalar)#
            lowerBound[2] <- 1#
          if (lambdaEst)#
            lowerBound <- c(lowerBound, bounds["lambda", 1])#
        }#
        if (is.null(upperBound)) {#
          upperBound <- log(bounds["acdcRate", 2]) / rootBranchingTime#
          if (acdcScalar)#
            upperBound[2] <- 20#
          if (lambdaEst)#
            upperBound <- c(upperBound, bounds["lambda", 2])#
        }
if (acdcScalar) {#
          var.funACDC <- function(param) {#
            if (lambdaEst) lambda <- tail(param, 1) else lambda <- 1#
            acdc.est <- param[1]#
            scalarRate <- param[2]#
            lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
            return(transformPhylo.ll(lambdaPhy, acdcRate = acdc.est, nodeIDs = node, model = "ACDC", y = y, cladeRates = scalarRate, imeserr = meserr, covPIC = covPIC)[[2]])#
          }#
        } else {#
          var.funACDC <- function(param) {#
            if (lambdaEst) lambda <- param[2] else lambda <- 1#
            acdc.est <- param[1]#
            lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
            return(transformPhylo.ll(lambdaPhy, acdcRate = acdc.est, nodeIDs = node, model = "ACDC", y = y, cladeRates = 1, meserr = meserr, covPIC = covPIC)[[2]])#
          }#
        }
vo <- optim(acdcRate, var.funACDC, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)
acdcRate
param=acdcRate
if (lambdaEst) lambda <- param[2] else lambda <- 1
acdc.est <- param[1]
lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)
return(transformPhylo.ll(lambdaPhy, acdcRate = acdc.est, nodeIDs = node, model = "ACDC", y = y, cladeRates = 1, meserr = meserr, covPIC = covPIC)[[2]])
node
node <- Ntip(phy) + 1
times <- nodeTimes(phy)[,1]
names(times) <- phy$edge[,1]
relations_num <- c(node, node.descendents(node, phy))
node.descendents(node, phy)
node
#' @title Phylogenetic tree transformations#
#' @description Transforms the branch lengths of a phylo object according to a model of trait evolution (see details).#
#' @param y A matrix of trait values.#
#' @param phy An object of class "phylo" (see ape package).#
#' @param model The model of trait evolution (see details).#
#' @param kappa Value of kappa transform.#
#' @param lambda Value of lambda transform.#
#' @param delta Value of delta transform.#
#' @param alpha Value of alpha (OU) transform.#
#' @param psi Value of psi transform.#
#' @param acdcRate Value of ACDC transform.#
#' @param nodeIDs Integer - ancestral nodes of clades.#
#' @param splitTime A split time (measured from the present, or most recent species) at which a shift in the rate occurs for the "timeSlice" model#
#' @param timeRates The rates (from ancient to recent) for the timeSlice model#
#' @param acdcScalar Logical.  For nested EB rate model, simultaneously estimated a rate scalar alongside EB model. Not  Default=FALSE.#
#' @param rateType If model="clade", a vector specifying if rate shift occurs in a clade ("clade") or on the single branch leading to a clade ("branch").#
#' @param branchRates Numeric vector specifying relative rates for individual branches#
#' @param cladeRates Numeric vector specifying telative rates for clades.#
#' @param cladeMembersObj Matrix of clade membership#
#' @param meserr A vector (or matrix) of measurement error for each tip. This is only applicable to univariate analyses.#
#' @param sigmaScale Scalar for measurement error.#
#' @details Transforms the branch lengths of a phylo object according to one of the following models:#
#' \itemize{#
#'  \item {model="bm"}- Brownian motion (constant rates random walk)#
#'  \item {model="kappa"} - fits Pagel's kappa by raising all branch lengths to the power kappa. As kappa approaches zero, trait change becomes focused at branching events. For complete phylogenies, if kappa approaches zero this infers speciational trait change. #
#'  \item {model="lambda"} - fits Pagel's lambda to estimate phylogenetic signal by multiplying all internal branches of the tree by lambda, leaving tip branches as their original length (root to tip distances are unchanged);#
#'  \item {model="delta"} - fits Pagel's delta by raising all node depths to the power delta. If delta <1, trait evolution is concentrated early in the tree whereas if delta >1 trait evolution is concentrated towards the tips. Values of delta above one can be difficult to fit reliably.#
#'  \item {model="free"} - fits Mooer's et al's (1999) free model where each branch has its own rate of trait evolution. This can be a useful exploratory analysis but it is slow due to the number of parameters, particularly for large trees.#
#'  \item {model="clade"} - fits a model where particular clades are a priori hypothesised to have different rates of trait evolution (see O'Meara et al. 2006; Thomas et al. 2006, 2009). Clades are specified using nodeIDs and are defined as the mrca node. Unique rates for each clade are specified using cladeRates. rateType specifies whether the rate shift occurs in the stem clade or on the single branch leading to the clade.#
#'  \item {model="OU"} - fits an Ornstein-Uhlenbeck model - a random walk with a central tendency proportional to alpha. High values of alpha can be interpreted as evidence of evolutionary constraints, stabilising selection or weak phylogenetic signal.#
#'  \item {model="psi"} - fits a model to assess to the relative contributions of speciation and gradual evolution to a trait's evolutionary rate (Ingram 2010). #
#' \item {model="ACDC"} {fits a model to in which rates can exponentially increased or decrease through time (Blomberg et al. 2003). If the upper bound is < 0, the model is equivalent to the 'Early Burst' model of Harmon et al. 2010. If a nodeIDs is supplied, the model will fit a ACDC model nested within a clade, with a BM fit to the rest of the tree.}#
#' \item {model="timeSlice"} {A model in which all branch rates change at time(s) in the past.}#
#'  }#
#' @return phy  A phylo object#
#' @references Ingram T. 2010. Speciation along a depth gradient in a marine adaptive radiation. Proceeding of the Royal Society B. In press.#
#' @references Mooers AO, Vamosi S, & Schluter D. 1999. Using phylogenies to test macroevolutionary models of trait evolution: sexual selection and speciation in Cranes (Gruinae). American Naturalist 154, 249-259.#
#' @references O'Meara BC, Ane C, Sanderson MJ & Wainwright PC. 2006. Testing for different rates of continuous trait evolution using likelihood. Evolution 60, 922-933#
#' @references Pagel M. 1997. Inferring evolutionary processes from phylogenies. Zoologica Scripta 26, 331-348.#
#' @references Pagel M. 1999 Inferring the historical patterns of biological evolution. Nature 401, 877-884.#
#' @references Thomas GH, Meiri S, & Phillimore AB. 2009. Body size diversification in Anolis: novel environments and island effects. Evolution 63, 2017-2030.#
#' @author Gavin Thomas, Mark Puttick#
#' @examples#
# Apply delta transform to anolis tree#
#' data(anolis.tree)#
#' anolis.treeDelta <- transformPhylo(phy=anolis.tree, model="delta", delta=0.5)#
#' @export#
#
transformPhylo <- function (phy, model = NULL, y = NULL, meserr=NULL, kappa = NULL, lambda = NULL, delta = NULL, alpha = NULL, psi = NULL, la = NULL, nodeIDs = NULL, rateType = NULL, branchRates = NULL, cladeRates = NULL,  splitTime = NULL, timeRates = NULL, acdcRate=NULL,  branchLabels = NULL) #
 {#
#
    n <- length(phy$tip.label)#
   if (is.null(meserr) == FALSE) {#
        if (dim(y)[2] > 1) {#
            meserr <- NULL#
            (stop("Measurement error can only be included for univariate models. Set meserr to NULL."))#
        }#
    }#
    switch(model, bm = {#
		   if (is.null(meserr) == FALSE) {#
		   height <- nodeTimes(phy)[1,1]#
		   interns <- which(phy$edge[, 2] > n)#
		   externs <- which(phy$edge[, 2] <= n)#
		   phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)*sigmaScale#
		   } else {#
		   phy <- phy#
		   }#
		   }, kappa = {#
		   	if(is.null(nodeIDs)) {#
		   		node <- Ntip(phy) + 1	#
		   		} else {#
		   		node <- nodeIDs#
		   		}#
		   	if (is.null(meserr) == FALSE) {#
		   		height <- nodeTimes(phy)[1,1]#
		   		interns <- which(phy$edge[, 2] > n)#
		   		externs <- which(phy$edge[, 2] <= n)#
		   		}#
		   	if(node == (Ntip(phy) + 1)) {#
		   		relations_num <- 1:(Nnode(phy) + Ntip(phy))#
		   	} else {#
		   		relations_num <- c(node.descendents(node, phy))#
		   	}#
		   	branches <- match(relations_num, phy$edge[,2])#
		   	if(any(is.na(branches))) branches <- branches[complete.cases(branches)]#
		   	branches <- sort(branches)#
		   	phy$edge.length[branches] <- phy$edge.length[branches] ^ kappa#
		   	if (is.null(meserr) == FALSE) {#
		   		phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
        		}#
		   }, lambda = {#
		   if (is.null(meserr) == FALSE) {#
		   height <- nodeTimes(phy)[1,1]#
		   interns <- which(phy$edge[, 2] > n)#
		   externs <- which(phy$edge[, 2] <= n)#
		   }#
		   if (is.ultrametric(phy)) {#
		   rootOrig <- nodeTimes(phy)[1,1]#
		   tips <- match(c(1:Ntip(phy)), phy$edge[, 2])#
		   phy$edge.length <- phy$edge.length * lambda#
		   phy$edge.length[tips] <- phy$edge.length[tips] + (rootOrig * (1 - lambda))#
		   }#
		   if (is.ultrametric(phy) == FALSE) {#
		   tips <- match(c(1:Ntip(phy)), phy$edge[, 2])#
		   cladeMat <- clade.matrix(phy)#
		   branchHeights <- sapply(1:Ntip(phy), function(x) sum(cladeMat$edge.length[cladeMat$clade.matrix[, x] == 1]))#
		   phy$edge.length <- phy$edge.length * lambda#
		   phy$edge.length[tips] <- phy$edge.length[tips] + (branchHeights * (1 - lambda))#
		   }#
		   if (is.null(meserr) == FALSE)	{#
		   	phy$edge.length[externs] <- phy$edge.length[externs] +  (meserr^2)/(var(y)/height)[1]#
		   	}#
		   }, delta = {#
		   if(is.null(nodeIDs)) {#
		   	node <- Ntip(phy) + 1#
		   	} else { #
		   	node <- nodeIDs#
		   	}#
		   allTimes <- nodeTimes(phy)#
		   if(node == phy$edge[1, 1]) {#
		   	 height <- allTimes[1,1]#
		   } else {#
		   	height <- allTimes[which(node == phy$edge[,2]), 2]#
		   }#
	   if (is.null(meserr) == FALSE) {#
		   	interns <- which(phy$edge[, 2] > n)#
		   	externs <- which(phy$edge[, 2] <= n)#
		   }#
		   times <- allTimes[match(c((Ntip(phy) + 1) : (Nnode(phy) + Ntip(phy))), phy$edge[,1]) , 1]#
		   names(times) <- (Ntip(phy) + 1):(Ntip(phy) + Nnode(phy))#
		   if(node == (Ntip(phy) + 1)) {#
		   		relations_num <- 1:(Nnode(phy) + Ntip(phy))#
		   	} else {#
		   		relations_num <- c(node.descendents(node, phy))#
			}#
		   originTime <- times[which(names(times) == node)][1]#
		   branches <- match(relations_num, phy$edge[,2])#
		   if(any(is.na(branches))) branches <- branches[complete.cases(branches)]#
		   times <- originTime - times#
		   tips <- Ntip(phy)#
		   res <- phy#
		   branches <- sort(branches)#
		   res$edge.length[branches] <- sapply(branches, function(x) {#
				bl <- phy$edge.length[x]#
		   		age <- times[phy$edge[x, 1] - tips]#
		   		(age + bl)^delta - age^delta#
		   		}#
		   	)#
		   phy <- res#
		   if (is.null(meserr) == FALSE)	{#
		   	phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
		   	}#
		   # allTimes2 <- nodeTimes(phy)#
		   # if(node == phy$edge[1, 1]) {#
		   	# height2 <- allTimes2[1,1]#
		   # } else {#
		   	# height2 <- allTimes2[which(node == phy$edge[,2]), 2]#
		   # }#
		   # height2 <- allTimes[1,1]#
		   # phy$edge.length[branches] <- phy$edge.length[branches] * (height/ height2)#
		   }, free = {#
		   if (is.null(meserr) == FALSE) {#
		   height <- nodeTimes(phy)[1,1]#
		   interns <- which(phy$edge[, 2] > n)#
		   externs <- which(phy$edge[, 2] <= n)#
		   }#
		   branchRates <- branchRates + (1 - min(branchRates))#
		   phy$edge.length <- phy$edge.length * branchRates#
		   if (is.null(meserr) == FALSE) {#
		   	phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
		   	}#
		   }, clade = {#
		   if (is.null(meserr) == FALSE) {#
		   height <- nodeTimes(phy)[1,1]#
		   interns <- which(phy$edge[, 2] > n)#
		   externs <- which(phy$edge[, 2] <= n)#
		   }#
		   if (is.null(rateType)) {#
		   rateType <- rep("clade", length(nodeIDs))#
		   } else {#
		   rateType <- rateType#
		   }#
		   branchShiftNms <- branchShiftID <- cladeShiftNms <- cladeShiftID <- NULL#
		   cladeMembers <- matrix(0, ncol = length(nodeIDs), nrow = length(phy$edge[, 1]))#
		   shiftType <- data.frame(rateType, nodeIDs, cladeRates)#
		   colnms <- paste(shiftType[, 1], shiftType[, 2], sep = "")#
		   shiftType <- data.frame(shiftType, colnms)#
		   if (sum(shiftType[, 1] == "clade") > 0) {#
		   cladeShiftID <- shiftType[shiftType[, 1] == "clade", 2]#
		   cladeShiftNms <- as.character(shiftType[shiftType[, 1] == "clade", 4])#
		   cladeMembers[, 1:length(cladeShiftID)] <- cladeIdentity(phy = phy, nodeIDs = cladeShiftID) #cladeMembersObj=cladeMembersObj)#
		   }#
		   if (sum(shiftType[, 1] == "branch") > 0) {#
		   branchShiftID <- shiftType[shiftType[, 1] == "branch", 2]#
		   branchShiftNms <- as.character(shiftType[shiftType[, 1] == "branch", 4])#
		   }#
		   if (is.null(branchShiftNms) == FALSE) { #
		   	colnames(cladeMembers) <- c(cladeShiftNms, rep(NA, length(branchShiftNms))) #
		   	} else  { #
		   	colnames(cladeMembers) <- cladeShiftNms#
		   	}#
		   if (sum(shiftType[, 1] == "branch") > 0) {#
		   for (i in 1:length(branchShiftID)) {#
			   branchID <- which(phy$edge[, 2] == branchShiftID[i])#
			   cladeMembers[branchID, ] <- 0#
			   cladeMembers[branchID, length(cladeShiftID) + i] <- 1#
			   colnames(cladeMembers)[length(cladeShiftID) + i] <- branchShiftNms[i]#
			   }#
		   }#
		   cladeMembers <- as.matrix(cladeMembers[, match(shiftType[, 4], colnames(cladeMembers))])#
		   for (i in 1:length(cladeRates)) {#
		   	phy$edge.length[cladeMembers[, i] == 1] <- phy$edge.length[cladeMembers[, i] == 1] * cladeRates[i]#
		   	}#
		   if (is.null(meserr) == FALSE) {#
            phy$edge.length[externs] <- phy$edge.length[externs] +(meserr^2)/(var(y)/height)[1]#
        	}#
		   }, OU = {#
		   if(is.null(nodeIDs)) { #
		   	node <- Ntip(phy) + 1#
		   	} else { #
		   	node <- nodeIDs#
		   	}#
		   times <- nodeTimes(phy)#
   		   height <- times[1,1]#
		   times <- times[match(c((Ntip(phy) + 1) : (Nnode(phy) + Ntip(phy))), phy$edge[,1]) , 1]#
		   names(times) <- (Ntip(phy) + 1):(Ntip(phy) + Nnode(phy))#
		   if (is.null(meserr) == FALSE) {#
		   		interns <- which(phy$edge[, 2] > n)#
		   		externs <- which(phy$edge[, 2] <= n)#
		   }#
			if(node == (Ntip(phy) + 1)) {#
		   		relations_num <- 1:(Nnode(phy) + Ntip(phy))#
		   	} else {#
		   		relations_num <- c(node.descendents(node, phy))#
		   	}#
#
		   originTime <- times[which(names(times) == node)][1]#
		   branches <- match(relations_num, phy$edge[,2])#
		   branches <- sort(branches)#
		   if(any(is.na(branches))) {#
		   	branches <- branches[complete.cases(branches)]#
		   	}#
			times2 <- nodeTimes(phy)[,1]#
			phy2 <- phy#
			edge.length.branches <- sapply(branches, function(i) {#
				Tmax <- originTime#
				bl <- phy$edge.length[i]#
				age <- times2[i]#
				t1 = originTime - age#
				t2 = t1 + bl#
				(1/(2 * alpha)) * exp(-2 * alpha * (Tmax - t2)) * (1 - exp(-2 * alpha * t2)) - (1/(2 * alpha)) * exp(-2 * alpha * (Tmax - t1)) * (1 - exp(-2 * alpha * t1))#
			})#
			phy2$edge.length[branches] <- edge.length.branches#
		   phy <- phy2#
		   if (is.null(meserr) == FALSE) { #
		   	phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
		   	}#
		   # times <- nodeTimes(phy)#
		   # times <- times[match(c((Ntip(phy) + 1) : (Nnode(phy) + Ntip(phy))), phy$edge[,1]) , 1]#
		   # names(times) <- (Ntip(phy) + 1):(Ntip(phy) + Nnode(phy))#
		   # originTime2 <- times[which(names(times) == node)][1]#
		   # phy$edge.length[branches] <- phy$edge.length[branches] * ( originTime /  originTime2)#
		   }, psi = {#
        if (is.null(meserr) == FALSE) {#
            height <- nodeTimes(phy)[1,1]#
            interns <- which(phy$edge[, 2] > n)#
            externs <- which(phy$edge[, 2] <= n)#
        }#
		if(is.null(phy$Sobs)){#
			Stot <- rep(1, length(phy$edge.length))#
		}else{#
			Stot<-phy$Sobs#
		}#
		if(!is.null(phy$Shid)) Stot<-Stot+phy$Shid#
        phy2 <- phy#
        phy2$edge.length <- (psi/(2*la)) * Stot + (1 - psi) * phy$edge.length#
        phy <- phy2#
        if (is.null(meserr) == FALSE) {#
            phy$edge.length[externs] <- phy$edge.length[externs] +#
            (meserr^2)/(var(y)/height)[1]#
        }#
         }, multipsi = {#
        if (is.null(meserr) == FALSE) {#
            height <- nodeTimes(phy)[1,1]#
            interns <- which(phy$edge[, 2] > n)#
            externs <- which(phy$edge[, 2] <= n)#
        }#
		if(is.null(phy$Sobs)){#
			Stot <- rep(1, length(phy$edge.length))#
		}else{#
			Stot <- phy$Sobs#
		}#
		if(!is.null(phy$Shid)) Stot <- Stot + phy$Shid#
        phy2 <- phy#
		states <- levels(factor(branchLabels))#
		for(i in 1:length(states)) {#
            phy2$edge.length[branchLabels==states[i]] <- (psi[i]/(2*la)) * Stot[branchLabels==states[i]] + (1 - psi[i]) * phy$edge.length[branchLabels==states[i]]#
		}#
        phy <- phy2#
        if (is.null(meserr) == FALSE) {#
            phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
        	}#
        }, #
        timeSlice = {#
		   if (is.null(meserr) == FALSE) {#
		   height <- nodeTimes(phy)[1,1]#
		   interns <- which(phy$edge[, 2] > n)#
		   externs <- which(phy$edge[, 2] <= n)#
		   }#
#
		   splitTime <- nodeTimes(phy)[1,1] - sort(splitTime, T)#
		   sliceLengths <- sliceTree(phy, splitTime)#
		   phy$edge.length <- as.vector(timeRates %*% t(sliceLengths))#
		   if (is.null(meserr) == FALSE) {#
		   	phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
		   	}#
		   } ,#
		ACDC = {#
			if(is.null(nodeIDs)) node <- Ntip(phy) + 1 else node <- nodeIDs#
			times <- nodeTimes(phy)[,1]#
			if (is.null(meserr) == FALSE) {#
				height <- times[1]#
				interns <- which(phy$edge[, 2] > n)#
				externs <- which(phy$edge[, 2] <= n)#
				}#
			names(times) <- phy$edge[,1]#
#
			if(node == (Ntip(phy) + 1)) {#
				relations_num <- 1:(Nnode(phy) + Ntip(phy))#
				} else {#
				relations_num <- c(node, node.descendents(node, phy))#
				}#
#
			originTime <- times[which(names(times) == node)][1]#
			branches <- match(relations_num, phy$edge[,2])#
			if(any(is.na(branches))) branches <- branches[complete.cases(branches)]#
			#branches <- sort(branches)#
			times <- nodeTimes(phy)[,1]#
			if(is.null(cladeRates) == FALSE) phy$edge.length[branches] <- phy$edge.length[branches] * cladeRates#
			edgeACDC <- sapply(branches, function(i) {#
				bl <- phy$edge.length[i]#
				age <- times[i]#
				t1 <- originTime - age#
				t2 <- t1 + bl#
				(exp(acdcRate * t2) - exp(acdcRate * t1))/(acdcRate)#
				})#
			phy$edge.length[branches] <- edgeACDC	#
			if (is.null(meserr) == FALSE)	 {#
				phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
					}#
				}#
		)#
		return(phy)#
}
acdc.ml <- transformPhylo.ML(phy, y=male.length, model="ACDC", profilePlot=T)
#' @title Phylogenetic tree transformations#
#' @description Transforms the branch lengths of a phylo object according to a model of trait evolution (see details).#
#' @param y A matrix of trait values.#
#' @param phy An object of class "phylo" (see ape package).#
#' @param model The model of trait evolution (see details).#
#' @param kappa Value of kappa transform.#
#' @param lambda Value of lambda transform.#
#' @param delta Value of delta transform.#
#' @param alpha Value of alpha (OU) transform.#
#' @param psi Value of psi transform.#
#' @param acdcRate Value of ACDC transform.#
#' @param nodeIDs Integer - ancestral nodes of clades.#
#' @param splitTime A split time (measured from the present, or most recent species) at which a shift in the rate occurs for the "timeSlice" model#
#' @param timeRates The rates (from ancient to recent) for the timeSlice model#
#' @param acdcScalar Logical.  For nested EB rate model, simultaneously estimated a rate scalar alongside EB model. Not  Default=FALSE.#
#' @param rateType If model="clade", a vector specifying if rate shift occurs in a clade ("clade") or on the single branch leading to a clade ("branch").#
#' @param branchRates Numeric vector specifying relative rates for individual branches#
#' @param cladeRates Numeric vector specifying telative rates for clades.#
#' @param cladeMembersObj Matrix of clade membership#
#' @param meserr A vector (or matrix) of measurement error for each tip. This is only applicable to univariate analyses.#
#' @param sigmaScale Scalar for measurement error.#
#' @details Transforms the branch lengths of a phylo object according to one of the following models:#
#' \itemize{#
#'  \item {model="bm"}- Brownian motion (constant rates random walk)#
#'  \item {model="kappa"} - fits Pagel's kappa by raising all branch lengths to the power kappa. As kappa approaches zero, trait change becomes focused at branching events. For complete phylogenies, if kappa approaches zero this infers speciational trait change. #
#'  \item {model="lambda"} - fits Pagel's lambda to estimate phylogenetic signal by multiplying all internal branches of the tree by lambda, leaving tip branches as their original length (root to tip distances are unchanged);#
#'  \item {model="delta"} - fits Pagel's delta by raising all node depths to the power delta. If delta <1, trait evolution is concentrated early in the tree whereas if delta >1 trait evolution is concentrated towards the tips. Values of delta above one can be difficult to fit reliably.#
#'  \item {model="free"} - fits Mooer's et al's (1999) free model where each branch has its own rate of trait evolution. This can be a useful exploratory analysis but it is slow due to the number of parameters, particularly for large trees.#
#'  \item {model="clade"} - fits a model where particular clades are a priori hypothesised to have different rates of trait evolution (see O'Meara et al. 2006; Thomas et al. 2006, 2009). Clades are specified using nodeIDs and are defined as the mrca node. Unique rates for each clade are specified using cladeRates. rateType specifies whether the rate shift occurs in the stem clade or on the single branch leading to the clade.#
#'  \item {model="OU"} - fits an Ornstein-Uhlenbeck model - a random walk with a central tendency proportional to alpha. High values of alpha can be interpreted as evidence of evolutionary constraints, stabilising selection or weak phylogenetic signal.#
#'  \item {model="psi"} - fits a model to assess to the relative contributions of speciation and gradual evolution to a trait's evolutionary rate (Ingram 2010). #
#' \item {model="ACDC"} {fits a model to in which rates can exponentially increased or decrease through time (Blomberg et al. 2003). If the upper bound is < 0, the model is equivalent to the 'Early Burst' model of Harmon et al. 2010. If a nodeIDs is supplied, the model will fit a ACDC model nested within a clade, with a BM fit to the rest of the tree.}#
#' \item {model="timeSlice"} {A model in which all branch rates change at time(s) in the past.}#
#'  }#
#' @return phy  A phylo object#
#' @references Ingram T. 2010. Speciation along a depth gradient in a marine adaptive radiation. Proceeding of the Royal Society B. In press.#
#' @references Mooers AO, Vamosi S, & Schluter D. 1999. Using phylogenies to test macroevolutionary models of trait evolution: sexual selection and speciation in Cranes (Gruinae). American Naturalist 154, 249-259.#
#' @references O'Meara BC, Ane C, Sanderson MJ & Wainwright PC. 2006. Testing for different rates of continuous trait evolution using likelihood. Evolution 60, 922-933#
#' @references Pagel M. 1997. Inferring evolutionary processes from phylogenies. Zoologica Scripta 26, 331-348.#
#' @references Pagel M. 1999 Inferring the historical patterns of biological evolution. Nature 401, 877-884.#
#' @references Thomas GH, Meiri S, & Phillimore AB. 2009. Body size diversification in Anolis: novel environments and island effects. Evolution 63, 2017-2030.#
#' @author Gavin Thomas, Mark Puttick#
#' @examples#
# Apply delta transform to anolis tree#
#' data(anolis.tree)#
#' anolis.treeDelta <- transformPhylo(phy=anolis.tree, model="delta", delta=0.5)#
#' @export#
#
transformPhylo <- function (phy, model = NULL, y = NULL, meserr=NULL, kappa = NULL, lambda = NULL, delta = NULL, alpha = NULL, psi = NULL, la = NULL, nodeIDs = NULL, rateType = NULL, branchRates = NULL, cladeRates = NULL,  splitTime = NULL, timeRates = NULL, acdcRate=NULL,  branchLabels = NULL) #
 {#
#
    n <- length(phy$tip.label)#
   if (is.null(meserr) == FALSE) {#
        if (dim(y)[2] > 1) {#
            meserr <- NULL#
            (stop("Measurement error can only be included for univariate models. Set meserr to NULL."))#
        }#
    }#
    switch(model, bm = {#
		   if (is.null(meserr) == FALSE) {#
		   height <- nodeTimes(phy)[1,1]#
		   interns <- which(phy$edge[, 2] > n)#
		   externs <- which(phy$edge[, 2] <= n)#
		   phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)*sigmaScale#
		   } else {#
		   phy <- phy#
		   }#
		   }, kappa = {#
		   	if(is.null(nodeIDs)) {#
		   		node <- Ntip(phy) + 1	#
		   		} else {#
		   		node <- nodeIDs#
		   		}#
		   	if (is.null(meserr) == FALSE) {#
		   		height <- nodeTimes(phy)[1,1]#
		   		interns <- which(phy$edge[, 2] > n)#
		   		externs <- which(phy$edge[, 2] <= n)#
		   		}#
		   	if(node == (Ntip(phy) + 1)) {#
		   		relations_num <- 1:(Nnode(phy) + Ntip(phy))#
		   	} else {#
		   		relations_num <- c(node.descendents(node, phy))#
		   	}#
		   	branches <- match(relations_num, phy$edge[,2])#
		   	if(any(is.na(branches))) branches <- branches[complete.cases(branches)]#
		   	branches <- sort(branches)#
		   	phy$edge.length[branches] <- phy$edge.length[branches] ^ kappa#
		   	if (is.null(meserr) == FALSE) {#
		   		phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
        		}#
		   }, lambda = {#
		   if (is.null(meserr) == FALSE) {#
		   height <- nodeTimes(phy)[1,1]#
		   interns <- which(phy$edge[, 2] > n)#
		   externs <- which(phy$edge[, 2] <= n)#
		   }#
		   if (is.ultrametric(phy)) {#
		   rootOrig <- nodeTimes(phy)[1,1]#
		   tips <- match(c(1:Ntip(phy)), phy$edge[, 2])#
		   phy$edge.length <- phy$edge.length * lambda#
		   phy$edge.length[tips] <- phy$edge.length[tips] + (rootOrig * (1 - lambda))#
		   }#
		   if (is.ultrametric(phy) == FALSE) {#
		   tips <- match(c(1:Ntip(phy)), phy$edge[, 2])#
		   cladeMat <- clade.matrix(phy)#
		   branchHeights <- sapply(1:Ntip(phy), function(x) sum(cladeMat$edge.length[cladeMat$clade.matrix[, x] == 1]))#
		   phy$edge.length <- phy$edge.length * lambda#
		   phy$edge.length[tips] <- phy$edge.length[tips] + (branchHeights * (1 - lambda))#
		   }#
		   if (is.null(meserr) == FALSE)	{#
		   	phy$edge.length[externs] <- phy$edge.length[externs] +  (meserr^2)/(var(y)/height)[1]#
		   	}#
		   }, delta = {#
		   if(is.null(nodeIDs)) {#
		   	node <- Ntip(phy) + 1#
		   	} else { #
		   	node <- nodeIDs#
		   	}#
		   allTimes <- nodeTimes(phy)#
		   if(node == phy$edge[1, 1]) {#
		   	 height <- allTimes[1,1]#
		   } else {#
		   	height <- allTimes[which(node == phy$edge[,2]), 2]#
		   }#
	   if (is.null(meserr) == FALSE) {#
		   	interns <- which(phy$edge[, 2] > n)#
		   	externs <- which(phy$edge[, 2] <= n)#
		   }#
		   times <- allTimes[match(c((Ntip(phy) + 1) : (Nnode(phy) + Ntip(phy))), phy$edge[,1]) , 1]#
		   names(times) <- (Ntip(phy) + 1):(Ntip(phy) + Nnode(phy))#
		   if(node == (Ntip(phy) + 1)) {#
		   		relations_num <- 1:(Nnode(phy) + Ntip(phy))#
		   	} else {#
		   		relations_num <- c(node.descendents(node, phy))#
			}#
		   originTime <- times[which(names(times) == node)][1]#
		   branches <- match(relations_num, phy$edge[,2])#
		   if(any(is.na(branches))) branches <- branches[complete.cases(branches)]#
		   times <- originTime - times#
		   tips <- Ntip(phy)#
		   res <- phy#
		   branches <- sort(branches)#
		   res$edge.length[branches] <- sapply(branches, function(x) {#
				bl <- phy$edge.length[x]#
		   		age <- times[phy$edge[x, 1] - tips]#
		   		(age + bl)^delta - age^delta#
		   		}#
		   	)#
		   phy <- res#
		   if (is.null(meserr) == FALSE)	{#
		   	phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
		   	}#
		   # allTimes2 <- nodeTimes(phy)#
		   # if(node == phy$edge[1, 1]) {#
		   	# height2 <- allTimes2[1,1]#
		   # } else {#
		   	# height2 <- allTimes2[which(node == phy$edge[,2]), 2]#
		   # }#
		   # height2 <- allTimes[1,1]#
		   # phy$edge.length[branches] <- phy$edge.length[branches] * (height/ height2)#
		   }, free = {#
		   if (is.null(meserr) == FALSE) {#
		   height <- nodeTimes(phy)[1,1]#
		   interns <- which(phy$edge[, 2] > n)#
		   externs <- which(phy$edge[, 2] <= n)#
		   }#
		   branchRates <- branchRates + (1 - min(branchRates))#
		   phy$edge.length <- phy$edge.length * branchRates#
		   if (is.null(meserr) == FALSE) {#
		   	phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
		   	}#
		   }, clade = {#
		   if (is.null(meserr) == FALSE) {#
		   height <- nodeTimes(phy)[1,1]#
		   interns <- which(phy$edge[, 2] > n)#
		   externs <- which(phy$edge[, 2] <= n)#
		   }#
		   if (is.null(rateType)) {#
		   rateType <- rep("clade", length(nodeIDs))#
		   } else {#
		   rateType <- rateType#
		   }#
		   branchShiftNms <- branchShiftID <- cladeShiftNms <- cladeShiftID <- NULL#
		   cladeMembers <- matrix(0, ncol = length(nodeIDs), nrow = length(phy$edge[, 1]))#
		   shiftType <- data.frame(rateType, nodeIDs, cladeRates)#
		   colnms <- paste(shiftType[, 1], shiftType[, 2], sep = "")#
		   shiftType <- data.frame(shiftType, colnms)#
		   if (sum(shiftType[, 1] == "clade") > 0) {#
		   cladeShiftID <- shiftType[shiftType[, 1] == "clade", 2]#
		   cladeShiftNms <- as.character(shiftType[shiftType[, 1] == "clade", 4])#
		   cladeMembers[, 1:length(cladeShiftID)] <- cladeIdentity(phy = phy, nodeIDs = cladeShiftID) #cladeMembersObj=cladeMembersObj)#
		   }#
		   if (sum(shiftType[, 1] == "branch") > 0) {#
		   branchShiftID <- shiftType[shiftType[, 1] == "branch", 2]#
		   branchShiftNms <- as.character(shiftType[shiftType[, 1] == "branch", 4])#
		   }#
		   if (is.null(branchShiftNms) == FALSE) { #
		   	colnames(cladeMembers) <- c(cladeShiftNms, rep(NA, length(branchShiftNms))) #
		   	} else  { #
		   	colnames(cladeMembers) <- cladeShiftNms#
		   	}#
		   if (sum(shiftType[, 1] == "branch") > 0) {#
		   for (i in 1:length(branchShiftID)) {#
			   branchID <- which(phy$edge[, 2] == branchShiftID[i])#
			   cladeMembers[branchID, ] <- 0#
			   cladeMembers[branchID, length(cladeShiftID) + i] <- 1#
			   colnames(cladeMembers)[length(cladeShiftID) + i] <- branchShiftNms[i]#
			   }#
		   }#
		   cladeMembers <- as.matrix(cladeMembers[, match(shiftType[, 4], colnames(cladeMembers))])#
		   for (i in 1:length(cladeRates)) {#
		   	phy$edge.length[cladeMembers[, i] == 1] <- phy$edge.length[cladeMembers[, i] == 1] * cladeRates[i]#
		   	}#
		   if (is.null(meserr) == FALSE) {#
            phy$edge.length[externs] <- phy$edge.length[externs] +(meserr^2)/(var(y)/height)[1]#
        	}#
		   }, OU = {#
		   if(is.null(nodeIDs)) { #
		   	node <- Ntip(phy) + 1#
		   	} else { #
		   	node <- nodeIDs#
		   	}#
		   times <- nodeTimes(phy)#
   		   height <- times[1,1]#
		   times <- times[match(c((Ntip(phy) + 1) : (Nnode(phy) + Ntip(phy))), phy$edge[,1]) , 1]#
		   names(times) <- (Ntip(phy) + 1):(Ntip(phy) + Nnode(phy))#
		   if (is.null(meserr) == FALSE) {#
		   		interns <- which(phy$edge[, 2] > n)#
		   		externs <- which(phy$edge[, 2] <= n)#
		   }#
			if(node == (Ntip(phy) + 1)) {#
		   		relations_num <- 1:(Nnode(phy) + Ntip(phy))#
		   	} else {#
		   		relations_num <- c(node.descendents(node, phy))#
		   	}#
#
		   originTime <- times[which(names(times) == node)][1]#
		   branches <- match(relations_num, phy$edge[,2])#
		   branches <- sort(branches)#
		   if(any(is.na(branches))) {#
		   	branches <- branches[complete.cases(branches)]#
		   	}#
			times2 <- nodeTimes(phy)[,1]#
			phy2 <- phy#
			edge.length.branches <- sapply(branches, function(i) {#
				Tmax <- originTime#
				bl <- phy$edge.length[i]#
				age <- times2[i]#
				t1 = originTime - age#
				t2 = t1 + bl#
				(1/(2 * alpha)) * exp(-2 * alpha * (Tmax - t2)) * (1 - exp(-2 * alpha * t2)) - (1/(2 * alpha)) * exp(-2 * alpha * (Tmax - t1)) * (1 - exp(-2 * alpha * t1))#
			})#
			phy2$edge.length[branches] <- edge.length.branches#
		   phy <- phy2#
		   if (is.null(meserr) == FALSE) { #
		   	phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
		   	}#
		   # times <- nodeTimes(phy)#
		   # times <- times[match(c((Ntip(phy) + 1) : (Nnode(phy) + Ntip(phy))), phy$edge[,1]) , 1]#
		   # names(times) <- (Ntip(phy) + 1):(Ntip(phy) + Nnode(phy))#
		   # originTime2 <- times[which(names(times) == node)][1]#
		   # phy$edge.length[branches] <- phy$edge.length[branches] * ( originTime /  originTime2)#
		   }, psi = {#
        if (is.null(meserr) == FALSE) {#
            height <- nodeTimes(phy)[1,1]#
            interns <- which(phy$edge[, 2] > n)#
            externs <- which(phy$edge[, 2] <= n)#
        }#
		if(is.null(phy$Sobs)){#
			Stot <- rep(1, length(phy$edge.length))#
		}else{#
			Stot<-phy$Sobs#
		}#
		if(!is.null(phy$Shid)) Stot<-Stot+phy$Shid#
        phy2 <- phy#
        phy2$edge.length <- (psi/(2*la)) * Stot + (1 - psi) * phy$edge.length#
        phy <- phy2#
        if (is.null(meserr) == FALSE) {#
            phy$edge.length[externs] <- phy$edge.length[externs] +#
            (meserr^2)/(var(y)/height)[1]#
        }#
         }, multipsi = {#
        if (is.null(meserr) == FALSE) {#
            height <- nodeTimes(phy)[1,1]#
            interns <- which(phy$edge[, 2] > n)#
            externs <- which(phy$edge[, 2] <= n)#
        }#
		if(is.null(phy$Sobs)){#
			Stot <- rep(1, length(phy$edge.length))#
		}else{#
			Stot <- phy$Sobs#
		}#
		if(!is.null(phy$Shid)) Stot <- Stot + phy$Shid#
        phy2 <- phy#
		states <- levels(factor(branchLabels))#
		for(i in 1:length(states)) {#
            phy2$edge.length[branchLabels==states[i]] <- (psi[i]/(2*la)) * Stot[branchLabels==states[i]] + (1 - psi[i]) * phy$edge.length[branchLabels==states[i]]#
		}#
        phy <- phy2#
        if (is.null(meserr) == FALSE) {#
            phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
        	}#
        }, #
        timeSlice = {#
		   if (is.null(meserr) == FALSE) {#
		   height <- nodeTimes(phy)[1,1]#
		   interns <- which(phy$edge[, 2] > n)#
		   externs <- which(phy$edge[, 2] <= n)#
		   }#
#
		   splitTime <- nodeTimes(phy)[1,1] - sort(splitTime, T)#
		   sliceLengths <- sliceTree(phy, splitTime)#
		   phy$edge.length <- as.vector(timeRates %*% t(sliceLengths))#
		   if (is.null(meserr) == FALSE) {#
		   	phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
		   	}#
		   } ,#
		ACDC = {#
			if(is.null(nodeIDs)) node <- Ntip(phy) + 1 else node <- nodeIDs#
			times <- nodeTimes(phy)[,1]#
			if (is.null(meserr) == FALSE) {#
				height <- times[1]#
				interns <- which(phy$edge[, 2] > n)#
				externs <- which(phy$edge[, 2] <= n)#
				}#
			names(times) <- phy$edge[,1]#
#
			if(node == (Ntip(phy) + 1)) {#
				relations_num <- 1:(Nnode(phy) + Ntip(phy))#
				} else {#
				relations_num <- c(node, node.descendents(node, phy))#
				}#
#
			originTime <- times[which(names(times) == node)][1]#
			branches <- match(relations_num, phy$edge[,2])#
			if(any(is.na(branches))) branches <- branches[complete.cases(branches)]#
			#branches <- sort(branches)#
			times <- nodeTimes(phy)[,1]#
			if(is.null(cladeRates) == FALSE) phy$edge.length[branches] <- phy$edge.length[branches] * cladeRates#
			edgeACDC <- sapply(branches, function(i) {#
				bl <- phy$edge.length[i]#
				age <- times[i]#
				t1 <- originTime - age#
				t2 <- t1 + bl#
				(exp(acdcRate * t2) - exp(acdcRate * t1))/(acdcRate)#
				})#
			phy$edge.length[branches] <- edgeACDC	#
			if (is.null(meserr) == FALSE)	 {#
				phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
					}#
				}#
		)#
		return(phy)#
}
acdc.ml <- transformPhylo.ML(phy, y=male.length, model="ACDC", profilePlot=T)
y=male.length.clade#
 modelCIs = TRUE#
 nodeIDs = NULL#
 lambdaEst = FALSE#
 acdcScalar = FALSE#
 profilePlot = T#
 lowerBound = NULL#
 upperBound = NULL#
 covPIC = TRUE#
 n.cores = 1#
 tol = NULL#
 meserr=NULL#
 controlList = c(fnscale = -1, maxit = 100, factr = 1e-7, pgtol = 0, type = 2, lmm = 5)#
 returnPhy = FALSE
acdcRate <- -0.01#
        if (acdcScalar)#
          acdcRate[2] <- 1#
        if (lambdaEst)#
          acdcRate <- c(acdcRate, 1)#
        if (is.null(nodeIDs))#
          node <- Ntip(phy) + 1 else node <- nodeIDs#
        rootBranchingTime <- nodeTimes(phy)[1, 1]#
        if (is.null(lowerBound)) {#
          lowerBound <- log(bounds["acdcRate", 1]) / rootBranchingTime#
          if (acdcScalar)#
            lowerBound[2] <- 1#
          if (lambdaEst)#
            lowerBound <- c(lowerBound, bounds["lambda", 1])#
        }#
        if (is.null(upperBound)) {#
          upperBound <- log(bounds["acdcRate", 2]) / rootBranchingTime#
          if (acdcScalar)#
            upperBound[2] <- 20#
          if (lambdaEst)#
            upperBound <- c(upperBound, bounds["lambda", 2])#
        }
if (acdcScalar) {#
          var.funACDC <- function(param) {#
            if (lambdaEst) lambda <- tail(param, 1) else lambda <- 1#
            acdc.est <- param[1]#
            scalarRate <- param[2]#
            lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
            return(transformPhylo.ll(lambdaPhy, acdcRate = acdc.est, nodeIDs = node, model = "ACDC", y = y, cladeRates = scalarRate, imeserr = meserr, covPIC = covPIC)[[2]])#
          }#
        } else {#
          var.funACDC <- function(param) {#
            if (lambdaEst) lambda <- param[2] else lambda <- 1#
            acdc.est <- param[1]#
            lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
            return(transformPhylo.ll(lambdaPhy, acdcRate = acdc.est, nodeIDs = node, model = "ACDC", y = y, cladeRates = 1, meserr = meserr, covPIC = covPIC)[[2]])#
          }#
        }#
        vo <- optim(acdcRate, var.funACDC, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)
node=NULL
node
if(is.null(nodeIDs)) node <- Ntip(phy) + 1 else node <- nodeIDs#
			times <- nodeTimes(phy)[,1]#
			if (is.null(meserr) == FALSE) {#
				height <- times[1]#
				interns <- which(phy$edge[, 2] > n)#
				externs <- which(phy$edge[, 2] <= n)#
				}
node
node == (Ntip(phy) + 1))
node == (Ntip(phy) + 1)
names(times) <- phy$edge[,1]
1:(Nnode(phy) + Ntip(phy))
relations_num <- 1:(Nnode(phy) + Ntip(phy))
originTime <- times[which(names(times) == node)][1]#
			branches <- match(relations_num, phy$edge[,2])#
			if(any(is.na(branches))) branches <- branches[complete.cases(branches)]#
			#branches <- sort(branches)#
			times <- nodeTimes(phy)[,1]
cladeRates=1
acdcRate=-1
if(is.null(cladeRates) == FALSE) phy$edge.length[branches] <- phy$edge.length[branches] * cladeRates#
			edgeACDC <- sapply(branches, function(i) {#
				bl <- phy$edge.length[i]#
				age <- times[i]#
				t1 <- originTime - age#
				t2 <- t1 + bl#
				(exp(acdcRate * t2) - exp(acdcRate * t1))/(acdcRate)#
				})#
			phy$edge.length[branches] <- edgeACDC	#
			if (is.null(meserr) == FALSE)	 {#
				phy$edge.length[externs] <- phy$edge.length[externs] + (meserr^2)/(var(y)/height)[1]#
					}#
				}#
		)
transformPhylo
var.funACDC <- function(param) {#
            if (lambdaEst) lambda <- param[2] else lambda <- 1#
            acdc.est <- param[1]#
            lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)#
            return(transformPhylo.ll(lambdaPhy, acdcRate = acdc.est, nodeIDs = node, model = "ACDC", y = y, cladeRates = 1, meserr = meserr, covPIC = covPIC)[[2]])#
          }
.
vo <- optim(acdcRate, var.funACDC, method = "L-BFGS-B", lower = lowerBound, upper = upperBound, control = controlList)
acdcRate
var.funACDC
param
if (lambdaEst) lambda <- param[2] else lambda <- 1#
            acdc.est <- param[1]#
            lambdaPhy <- transformPhylo(y = y, phy = phy, lambda = lambda, model = "lambda", meserr = meserr)
transformPhylo.ll(lambdaPhy, acdcRate = acdc.est, nodeIDs = node, model = "ACDC", y = y, cladeRates = 1, meserr = meserr, covPIC = covPIC)[[2]]
lambdaPhy
node
Ntip(phy)
acdc.ml <- transformPhylo.ML(phy, y=male.length, model="ACDC", profilePlot=T)
transformPhylo
